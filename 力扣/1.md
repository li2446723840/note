1、给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。

```js
var twoSum = function(list, target) {
  const map = new Map();
  for(let i = 0; i < list.length; i++) {
    if (map.has(target - list[i])) {
      return [map.get(target - list[i]), i]
    } else {
      map.set(list[i], i);
    }
  }
  return []
};
console.log(twoSum([2,7,11,15], 9));
```

2、给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

```js
// 解法1：
var addTwoNumbers = function(l1, l2) {
  return String(Number(l1.reverse().join("")) + Number(l2.reverse().join(""))).split("").reverse().map(item => Number(item))
};
// 解法2：
var addTwoNumbers = function (l1, l2) {
  const big = l1.length >= l2.length ? l1 : l2;
  const small = l1.length >= l2.length ? l2 : l1;
  let mark = false;
  let list = [];
  for (let i = 0; i < big.length; i++) {
    let result = big[i] + (small[i] || 0);
    mark && result++;
    if (result >= 10) {
      mark = true;
      result = result - 10;
    } else {
      mark = false;
    }
    list.push(result);
  }
  mark && list.push(1);
  return list;
};
console.log(addTwoNumbers([9, 9, 9, 9, 9, 9, 9], [9, 9, 9, 9]));
```

3、给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

```js
var lengthOfLongestSubstring = function (str) {
  if (str.length <= 1) {
    return str.length;
  }
  let left = 0;
  let right = 1;
  let max = 0;
  let temp;
  while (right < str.length) {
    temp = str.slice(left, right);
    if (temp.indexOf(str.charAt(right)) > -1) {
      left ++;
      continue;
    } else {
      right++;
    }
    if (right - left > max) {
      max = right - left;
    }
  }
  return max;
};
console.log(lengthOfLongestSubstring("abscasdjuywbcbb"));
```

4、寻找两个正序数组的中位数。给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。算法的时间复杂度应该为 O(log (m+n)) 。

```js
var findMedianSortedArrays = function (list1, list2) {
  const arr = list1.concat(list2).sort();
  if (arr.length % 2) {
    return arr[Math.floor(arr.length / 2)];
  } else {
    return (
      (arr[Math.floor(arr.length / 2) - 1] + arr[Math.floor(arr.length / 2)]) /
      2
    );
  }
};
console.log(findMedianSortedArrays([1,2,4,5,8],[4,6,7,9]));
```

